X, Y, W, S = map(int, input().split())

A = (X + Y) * W
B = min(X, Y) * S + abs(X - Y) * W

# if X > Y:
#     if X % 2:
#         C = (X - 1) * S + W
#     else:
#         C = X * S
# else:
#     C = 10 ** 100

# 대각선만으로 이동할 때의 최소 거리 by chatgpt
# 내가 놓친 것 => Y좌표 이상으로 가도 괜찮다
# 목표로부터 멀어지면 더 늦어질거라는 고정관념 때문에 놓친 부분
if (X + Y) % 2 == 0:
    C = max(X, Y) * S
else:
    C = (max(X, Y) - 1) * S + W
print(min(A, B, C))

#-------------------------------
# 필기 내용
# 백준 - 1459 / 걷기

# 1. 시작은 무조건 (0, 0)
# 2. 목표는 (X, Y)
# 3. 이동방법은 두 가지
#     1. 가로 또는 세로
#     2. 대각선
#     3. 단 두 방식의 소요시간은 다르다

# 입력방식
# X, Y, W, S
# X, Y: 집의 위치(< 1000000000)
# W: 걸어서 한 블록 가는데 걸리는 시간(< 10000)
# S: 대각선으로 가로지르는 시간(<10000)

# 해결방안
# DFS하면 recursion error 100%
# 그러면 최소 경우의 수는 두 가지
# 1. 가로, 세로만 사용한 경우
# 2. 대각선까지 사용한 경우

# 1번의 경우는 X + Y 값을 W에 곱하면 될듯
# 2번의 경우 X, Y 중 작은 값만큼 이동하고 나머지를 남은 X, Y 값으로 이동하게 하면 되지 않을까??

# => 검증
# 예제 1번 케이스
# X, Y, W, S = 4, 2, 3, 10
# 1번 경우 6 * 3 = 18
# 2번 경우 2 * 10 + 2 * 3 = 26
# 이러면 답은 18이 되어야하는데 // 정답

# 예제 2번
# X, Y, W, S = 4, 2, 3, 5
# 1번 경우 6 * 3  = 18
# 2번 경우 2 * 5 + 2 * 3  = 16
# 답 16 // 정답

# 이걸 기반으로 작성해본다
# => 오답

# 대각선이 가능하려면 무조건 Y값이 0보다 커야할줄 알았는데 그건 아닌듯하다
# (0, 0) => (1, 1) => (2, 0)이 가능한듯

# 원점과 (X, Y) 지점까지를 45도 대각선과 직선을 최소한으로 사용한 방법
# 1. 대각선
# 2. 가로 + 세로
# 3. 대각선 + 가로
# 4. 대각선 + 세로
# 5. 대각선 + 대각선

# 1,5 / 2 / 3, 4로 모을 수 있다

# 3538